<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY rfc2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY rfc3447 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3447.xml">
<!ENTITY rfc5114 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5114.xml">
<!ENTITY rfc6234 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6234.xml">
<!ENTITY rfc7748 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7748.xml">
<!ENTITY rfc8080 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.8080.xml">
<!ENTITY I-D.vcelak-nsec5 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.vcelak-nsec5.xml">
]>
<?rfc toc="yes"?>
<?rfc symrefs="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<?rfc strict="no"?>
<?rfc rfcedstyle="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>

<rfc category="std" docName="draft-goldbe-vrf-00" ipr="trust200902">
    <front>
        <title abbrev="VRF">Verfiable Random Functions (VRFs)</title>

        <author fullname="Sharon Goldberg" initials="S." surname="Goldberg">
            <organization>Boston University</organization>
            <address>
                <postal>
                    <street>111 Cummington St, MCS135</street>
                    <city>Boston</city>
                    <region>MA</region>
                    <code>02215</code>
                    <country>USA</country>
                </postal>
                <email>goldbe@cs.bu.edu</email>
            </address>
        </author>

        <author fullname="Dimitrios Papadopoulos" initials="D." surname="Papadopoulos">
            <organization>University of Maryland</organization>
            <address>
                <postal>
                    <street>8223 Paint Branch Dr</street>
                    <city>College Park</city>
                    <region>MD</region>
                    <code>20740</code>
                    <country>USA</country>
                </postal>
                <email>dipapado@bu.edu</email>
            </address>
        </author>

        <author fullname="Jan Vcelak" initials="J." surname="Vcelak">
            <organization>NS1</organization>
            <address>
                <postal>
                    <street>16 Beaver St</street>
                    <city>New York</city>
                    <region>NY</region>
                    <code>10004</code>
                    <country>USA</country>
                </postal>
                <email>jvcelak@ns1.com</email>
            </address>
        </author>

        <date year="2017" />

        <!-- <workgroup></workgroup> -->

        <keyword>public key cryptography</keyword>
        <keyword>hashing</keyword>
        <keyword>authenticated denial</keyword>
        
    <abstract>

       <t>
        A Verifiable Random Function (VRF) is the public-key version of a
        keyed cryptographic hash. Only the holder of the private key
        can compute the hash, but anyone with public key
        can verify the correctness of the hash.    
        VRFs are useful for preventing enumeration of hash-based data structures.
        This document specifies several VRF constructions that are secure in
        the cryptographic random oracle model. One  VRF uses RSA and the other
        VRF uses Eliptic Curves (EC). 
        </t>

    </abstract>

</front>

<middle>

    <section title="Introduction" anchor="intro">

        <section title="Rationale">

    <t>
   A verifiable random function 
   VRF <xref target="MRV99"></xref> is the public-key version of a
   keyed cryptographic hash. Only the holder of the private VRF key
   SK can compute the hash, but anyone with public key
   PK can verify the correctness of the hash. 
   </t>
   
   <t>
   One application of the VRF is to prevent offline 
   enumeration of the data stored in a hash-based data structure. 
   In this application, 
   a Prover holds the VRF secret key SK and uses VRF hashing to 
   construct a hash-based data structure on some input data.  
   
   Because hashing is done with the VRF, only 
   the Prover can answer queries about whether or not some data is stored 
   in the data structure.   Anyone that knows the  public VRF key PK can 
   verify that the Prover has answered queries correctly. However, because
   these other parties do not know the private VRF key SK, they cannot 
   make offline inferences (that do not involve querying the Prover) about 
   which data is stored in the data structure. This prevents offline 
   enumeration of the data in the data structure.
   VRFs are used for this purpose in the NSEC5 
   construction for DNSSEC Authenticated Denial of Existence (see <xref
   target="nsec5ecc"/> and <xref target="I-D.vcelak-nsec5"/>).
   </t>
   </section>
   
        <section title="Requirements">
            <t>
                The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
                "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
                document are to be interpreted as described in
                <xref target="RFC2119" />.
            </t>
        </section>
   
        <section title="Terminology">
                
            <t>
                The following terminology is used through this document:
            </t>

            <t>
                <list style="hanging">
                    <!--<t hangText="SK:">
                        The private key for the VRF. 
                    </t>
                    <t hangText="PK:">
                        The public key for the VRF. 
                    </t>-->
                    <t hangText="alpha:">
                        The input to be hashed by the VRF. 
                    </t>
                    <t hangText="beta:">
                        The VRF hash output. 
                    </t>
                    <t hangText="pi:">
                        The VRF proof. 
                    </t>
                </list>
            </t>
        </section>
   
   </section>
   
   <section title="VRF Algorithms">
   <t> 
   A VRF hashes an input alpha using the private key SK to obtain
   
    <list>
    <t> beta = VRF_hash(SK, alpha) </t>
    </list>
   
   The VRF_hash algorithm MUST be deterministic, in 
   the sense that it will always produce the same output beta given a 
   pair of inputs (SK, alpha).
   
   The private key SK is also used to construct a 
   proof pi that beta is the correct hash output 
   <list>
        <t>pi = VRF_prove(SK, alpha)</t>
   </list>
   The proof pi is allows anyone holding the public key 
   to verify that indeed beta is the correct hash of alpha
   under key PK. Thus, the VRF also comes with an algorithm
   <list>
   <t>   VRF_verify(PK, alpha, beta, pi)</t>
   </list>
   which outputs VALID when beta is the correct VRF hash of alpha 
   under key PK, and outputs INVALID otherwise.    
   </t>
   
   <section title="VRF Proof-to-Hash Property">
   
   <t> Some VRFs support an additional property that allows anyone to
   obtain the hash output beta directly from the proof value pi 
   <list>
   <t> beta = VRF_proof2hash(pi) </t>
   </list>
      The VRF_hash function is therefore given by
   <list>
        <t>beta = VRF_hash(SK, alpha) = VRF_proof2hash(VRF_prove(SK, alpha))</t>
   </list>  
   For these VRFs, the verification function only needs to take in the public 
   key PK, the VRF input alpha, and the VRF proof pi, so that 
   <list>
   <t> VRF_verify(PK, alpha, pi) </t>
   </list>
   outputs VALID if beta=VRF_proof2hash(pi) is correct VRF hash of alpha 
   under key PK, and outputs INVALID otherwise.
   </t>   
   
   <t>
   (Notice that any VRF can be made to satisfy this property by redefining the 
   VRF proof value to include both beta and pi. )
   </t>
   </section>
   </section>
   
   
   <section title="VRF Security Properties">
   
   <t>
   This document defines VRFs that satisfies the following security properties:
   </t>
   
   <t>
   <list style="hanging">
        <t hangText="Trusted uniqueness:">
        Suppose the public and private VRF keys (PK, SK) were generated
        in a trustworthy manner. Then, for any VRF input alpha,
        even an adversary that knows SK cannot produce a valid proof pi, for 
        an incorrect VRF hash output beta', where beta' is different than
        beta = VRF_hash(SK, alpha).  This implies that, for a fixed public VRF
        key PK, there is a unique VRF output beta for each VRF input alpha.
        </t>
        
        <t hangText="Pseudorandomness:">
             Roughly speaking, pseudorandomness ensures that every VRF output 
             beta looks random to anyone who knows the corresponding
             VRF input alpha, but who does not know the secret VRF key SK 
             or a valid VRF proof pi corresponding to alpha.
        </t>  
        <t>
             [Leo to write
             this to make sure it says the right thing about selective vs adaptive 
             security. Here is some candidate text: 
             Suppose the public and private VRF keys (PK, SK)
             were generated in a trustworthy manner, and consider an adversary 
             that knows PK but not SK.
             Then, for any VRF input alpha that is known by the 
             adversary, the adversary cannot distinguish its corresponding 
             valid VRF output beta from a random value. ]
        </t>
        
        <t> 
        It is important to remember that the VRF output beta does not 
        look random to a party that knows the private VRF key SK!  Such a party
        can easily distinguish beta from a random value by comparing it to 
        the result of VRF_hash(SK, alpha).           
        </t>
        <t> Also, the VRF output beta does not look random to any party that
        knows valid VRF proof pi corresponding to the VRF input alpha, even 
        if that party does not know the private VRF key SK.
        Such a party can easily distinguish beta from a random value by checking 
        whether VRF_verify(PK, alpha, beta, pi) returns "VALID".
        </t>
  
        <t hangText="Collison resistence:">
            [LEO TO ADD TEXT HERE.]    
        </t>
   </list>
   </t> 
  
    <t> Applications that use the VRFs defined in this 
    document MUST ensure that that the VRF key is generated in a
    trustworthy manner. See <xref target="securitycons"/> for more discussion.
    </t>
   
     </section>
   
    <section title="RSA Full Domain Hash VRF (RSA-FDH-VRF)" anchor="fdh">
        <t>
            The RSA Full Domain Hash  VRF (RSA-FDH-VRF) is VRF that 
            satisfies the trusted 
            uniqueness, pseudorandomness and collision resistance properties. 
            Its security follows from the standard RSA assumption 
            in the random oracle model.  Formal security proofs are in 
            <xref target="nsec5ecc" />. 
            This VRF also supports the VRF proof-to-hash property, 
            that allows the hash output beta to be 
            obtained directly from the proof value pi.
        </t>

        <t> The VRF computes the proof pi as a deterministic RSA signature on
            input alpha using the RSA Full Domain Hash Algorithm 
            <xref target="RFC3447" /> parametrized with
            Hash, where Hash is a secure hash algorithm.   RSA signature
            verification is used to verify the correctness of the proof.
            The VRF hash output beta is simply given by Hash(pi). 
        </t>
    
        <t>
            In this document, the notation from <xref target="RFC3447" /> is used.
        </t>

        <t>
            Used parameters:
            <list>
                <t>(N, e) - RSA public key</t>
                <t>SK - RSA private key</t>
                <t>n - length of the RSA modulus N in octets</t>
            </list>
        </t>

        <t>
            Fixed options:
            <list>
                <t>Hash - secure cryptographic hash algorithm.  
                The cryptographic security level
                of this hash algorithm MUST be at least as high as 
                the cryptographic security level of the RSA key.  
                </t>
                
            </list>
        </t>

        <t>
            Used primitives:
            <list>
                <t>
                    I2OSP - Coversion of a nonnegative integer to an octet string as defined in
                    Section 4.1 of <xref target="RFC3447" />
                </t>
                <t>
                    OS2IP - Coversion of an octet string to a nonnegative integer as defined in
                    Section 4.2 of <xref target="RFC3447" />
                </t>
                <t>
                    RSASP1 - RSA signature primitive as defined in
                    Section 5.2.1 of <xref target="RFC3447" />
                </t>
                <t>
                    RSAVP1 - RSA verification primitive as defined in
                    Section 5.2.2 of <xref target="RFC3447" />
                </t>
                <t>
                    MGF1 - Mask Generation Function based on a hash function as defined in
                    Section B.2.1 of <xref target="RFC3447" />
                </t>
            </list>
        </t>

        <section title="RSA-FDH-VRF Proving">
            <t>
                RSA-FDH-VRF_prove(SK, alpha)
            </t>

            <t>
                Input:
                <list>
                    <t>SK - RSA private key</t>
                    <t>alpha - VRF hash input, an octet string</t>
                </list>
            </t>

            <t>
                Output:
                <list>
                    <t>S - proof, an octet string of length n</t>
                </list>
            </t>

            <t>
                Steps:
                <list style="numbers">
                    <t>EM = MGF1(alpha, n - 1)</t>
                    <t>m = OS2IP(EM)</t>
                    <t>s = RSASP1(SK, m)</t>
                    <t>pi = I2OSP(s, n)</t>
                    <t>Output pi</t>
                </list>
            </t>
        </section>
        
        <section title="RSA-FDH-VRF Proof To Hash">
            <t>
                RSA-FDH-VRF_proof2hash(pi)
            </t>

            <t>
                Input:
                <list>
                    <t>pi - proof, an octet string of length n</t>
                </list>
            </t>
            
            <t>
                Output:
                <list>
                    <t>beta - VRF hash output</t>
                </list>
            </t>

            <t>
                Steps:
                <list style="numbers">
                    <t>beta = Hash(pi)</t>
                    <t>Output beta</t>
                </list>
            </t>
        </section>

        <section title="RSA-FDH-VRF Verifying">
            <t>
                RSA-FDH-VRF_verify((N, e), alpha, S)
            </t>

            <t>
                Input:
                <list>
                    <t>(N, e) - RSA public key</t>
                    <t>alpha - VRF hash input, an octet string</t>
                    <t>pi - proof to be verified, an octet string of length n</t>
                </list>
            </t>

            <t>
                Output:
                <list>
                    <t>"VALID" or "INVALID"</t>
                </list>
            </t>

            <t>
                Steps:
                <list style="numbers">
                    <t>s = OS2IP(pi)</t>
                    <t>m = RSAVP1((N, e), s)</t>
                    <t>EM = I2OSP(m, n - 1)</t>
                    <t>EM' = MGF1(alpha, n - 1)</t>
                    <t>
                        If EM and EM' are the same, output "VALID";
                        else output "INVALID".
                    </t>
                </list>
            </t>
        </section>
 
    </section>

    <section title="Elliptic Curve VRF" anchor="ecvrf">
        
        <t>
            The Elliptic Curve Verifiable Random Function (EC-VRF) is VRF that 
            satisfies the trusted uniqueness, pseudorandomness and collision 
            resistance properties. This VRF operate in a cyclic group G of prime order 
            with generator g, where the cyclic group is an elliptic curve group.
            EC points in group G are encoded using point compression.
            </t>
            
        <t>
            The security of this VRF  follows from the decisional 
            Diffie-Hellman (DDH) assumption in the 
            cyclic group G  in the random oracle model.  Formal security proofs 
            are in <xref target="nsec5ecc" />. This VRF also supports the 
            proof-to-hash  property, that allows the hash output beta to be 
            obtained directly from the proof value pi.
        </t>
            
        <t>
            Fixed options:
            <list>
                <t>G - EC group</t>
                <t>2n - length, in octets, of a single coordinate of an EC point in G
                <cref source="Sharon">n is 16 octects for a 256 bit curve. this is probably
                a better way to word this.</cref></t>
                <t>Hash - secure cryptographic hash function producing outputs of length 2n.
                The cryptographic security level
                of this hash algorithm MUST be at least as high as
                the cryptographic security level of the EC Group G.                  
                </t>
            </list>
        </t>

        <t>
            Used parameters:
            <list>
                <t>g^x - EC public key</t>
                <t>x - EC private key</t>
                <t>q - prime order of group G</t>
                <t>g - generator of group G</t>
             </list>
        </t>

        <t>
            Used primitives:
            <list>
                <t>"" - empty octet string</t>
                <t>|| - octet string concatenation</t>
                <t>p^k - EC point multiplication</t>
                <t>p1*p2 - EC point addition</t>
                <t>ECP2OS - EC point to octet string conversion with point compression as specified in Section 2.3.3 of <xref target="SECG1" /></t>
                <t>OS2ECP - octet string to EC point conversion with point compression as specified in Section 2.3.4 of <xref target="SECG1" /></t>
            </list>
        </t>



        <section title="EC-VRF Proving">
            <t>
                EC-VRF_prove(g^x, x, alpha)
            </t>

            <t>
                Input:
                <list>
                    <t>g^x - EC public key</t>
                    <t>x - EC private key</t>
                    <t>alpha - VRF input, octet string</t>
                </list>
            </t>

            <t>
                Output:
                <list>
                    <t>pi - VRF proof, octet string (5n+1 octets)
                    <cref source="Sharon">81 octets for a 256-bit EC G</cref></t>
                </list>
            </t>

            <t>
                Steps:
                <list style="numbers">
                    <t>h = EC-VRF_hash_to_curve(alpha)</t>
                    <t>gamma = h^x</t>
                    <t>choose a random nonce k from [0, q-1]</t>
                    <t>c = EC-VRF_hash_points(g, h, g^x, h^x, g^k, h^k)</t>
                    <t>s = k - c*q mod q</t>
                    <t>pi = ECP2OS(gamma) || I2OSP(c, n) || I2OSP(s, 2n)</t>
                    <t>Output pi</t>
                </list>
            </t>
        
            <t>Note: gamma is an EC point in G encoded with point compression.
            gamma has length 2n+1 octets.</t>
            
        </section>


        <section title="EC-VRF Proof To Hash">
            <t>
                EC-VRF_proof2hash(pi)
            </t>
            <t>
                Input:
                <list>
                    <t>pi - VRF proof (5n+1 octets)</t> 
                </list>
            </t>
            <t>
                Output:
                <list>
                    <t>beta - VRF hash output, octet string (2n octets)</t>
                </list>
            </t>
            <t>
                Steps:
                <list style="numbers">
                    <t>gamma, c, s = EC-VRF_decode_proof(pi)</t>
                    <t>gamma is an EC point in G with coordinates (x, y)</t>
                    <t><cref source="Sharon">DO WE WANT TO CHECK THAT "gamma is a valid EC point in G" HERE?</cref></t>
                    <t>beta = I2OSP(x, 2n)</t>
                    <t>Output beta</t>
                </list>
            </t>
            <t>
                Note: Because of the format of the point-compressed form of an 
                elliptic curve, the hash can
                be retrieved from an encoded gamma simply by omitting the first octet of the gamma.
                <cref source="Sharon">This is probably true for p-256 curve,
                since Jan wrote this in an earlier verion, but it is true 
                for the Ed25519 and Ed488 curves?</cref>
            </t>
        </section>


        <section title="EC-VRF Verifying">
            <t>
                EC-VRF_verify(g^x, pi, alpha)
            </t>

            <t>
                Input:
                <list>
                    <t>g^x - EC public key</t>
                    <t>pi - VRF proof, octet string</t>
                    <t>alpha - VRF input, octet string</t>
                </list>
            </t>

            <t>
                Output:
                <list>
                    <t>"VALID" or "INVALID"</t>
                </list>
            </t>

            <t>
                Steps:
                <list style="numbers">
                    <t>gamma, c, s = EC-VRF_decode_proof(pi)</t>
                    <t>
                        If gamma is not a valid EC point in G,
                        stop and output "INVALID".
                        
                        <cref source="Jan">TODO: check validity of gamma before hashing</cref>
                        <cref source="Sharon">I added this item on the list 
                        above to deal with this todo</cref>
 
                    </t>
                    <t>u = (g^x)^c * g^s</t>
                    <t>h = EC-VRF_hash_to_curve(alpha)</t>
                    <t>v = gamma^c * h^s</t>
                    <t>c' = EC-VRF_hash_points(g, h, g^x, gamma, u, v)</t>
                    <t>
                        If c and c' are the same, output "VALID";
                        else output "INVALID". 
                    </t>
                </list>
            </t>
        </section>


        <section title="EC-VRF Auxiliary Functions">

        <section title="EC-VRF Hash To Curve">
        
            <t>
            The following EC-VRF_hash_points algorithm provides a simple and 
            generic way to hash an octet string onto any elliptic curve.  
            </t>
            
            <t>
            However, this EC-VRF_hash_points algorithm MUST NOT used in applications where 
            the VRF input alpha must be kept secret. This is because the running time of 
            the hashing algorithm depends on alpha, and so it is susceptible to 
            timing attacks.  That said, the amount of information obtained from
            such a timing attack is likely to be small, since the algorithm 
            is expected to find a valid curve point after only two attempts 
            (i.e., when ctr=1) on average.  See <cref source="Sharon">Dimitris
            add cite here please!</cref>.
            </t>
            
            <t>
            (Note: This timing attack is not relevant in the context 
            of NSEC5 <xref target="I-D.vcelak-nsec5"/>. The only value that 
            is processed by the VRF online in response to an adversary's 
            query with NSEC5 is the queried name alpha itself. Thus 
            alpha is already known to the adversary.)
            </t>
            
            
            <t>
                EC-VRF_hash_to_curve(m)
            </t>
            <t>
                Input:
                <list>
                    <t>m - value to be hashed, an octet string</t>
                </list>
            </t>
            <t>
                Output:
                <list>
                    <t>h - hashed value, EC point in G</t>
                </list>
            </t>
            <t>
                Steps:
                <list style="numbers">
                    <t>ctr = 0</t>
                    <t>While true:
                    <list style="letters">                
                        <t>CTR = I2OSP(ctr, 4)</t>
                        <t>p = 0x02 || Hash(m || CTR). (Note, 0x02 sets point encoding 
                        to "compressed", using only the positive value for the y-coefficient.)
                        <cref source="Sharon">Jan, why did you choose on 02, we could 
                        also try 03 for the negative y coordinate, right? Also, Dimitris,
                        we need a cite for the
                        0x02 comment above.</cref>
                        </t>
                        <t>Break if p is a valid octet string representing encoded compressed point in G.</t>
                        <t>ctr = ctr + 1</t>
                    </list>
                    </t>
                    <t>h = OS2ECP(p)</t>
                    <t>Output h</t>
                </list>
            </t>
            
            <t>For applications where VRF input alpha must be kept secret,
            the following EC-VRF_hash_points algorithm MAY be used to used as  
            generic way to hash an octet string onto any elliptic curve.
            </t>
            

            <t>[TODO: Specify a generic hash_to_curve algorithm that is not susceptible 
            to timing attacks. <cref source="Sharon">Dimitris can you add a cite
            to the research paper that shows how to do this? I don't think we need to 
            add the full spec for this version of the draft.</cref>]
            </t>
        </section>

        <section title="EC-VRF Hash Points">
                     
            <t>
                EC-VRF_hash_points(p_1, p_2, ..., p_j)
            </t>
            <t>
                Input:
                <list>
                    <t>p_i - EC point in G</t>
                </list>
            </t>
            <t>
                Output:
                <list>
                    <t>h - hash value, integer between 0 and 2^(8n)-1 
                    <cref source="Sharon">This is an int between 0 and 2^128-1 for
                    a 256 bit curve. Remember that n=16 for such a curve</cref></t>
                </list>
            </t>
            <t>
                Steps:
                <list style="numbers">
                    <t>P = ""</t>
                    <t>for p_i in [p_1, p_2, ... p_j]:
                       <vspace/>P = P || ECP2OS(p_i)
                    </t>
                    <t>h' = Hash(P) 
                    <cref source="Sharon">Hash is SHA-256 in the 
                    P-256 reference implementation</cref>
                    </t>
                    <t>h = OS2IP(first n octets of h')</t>
                    <t>Output h</t>
                </list>
            </t>
            
            
                   
        </section>

        <section title="EC-VRF Decode Proof">
            <t>
                EC-VRF_decode_proof(pi)
            </t>
            <t>
                Input:
                <list>
                    <t>pi - VRF proof, octet string (5n+1 octets)</t>
                </list>
            </t>
            <t>
                Output:
                <list>
                    <t>gamma - EC point</t>
                    <t>
                    c - integer between 0 and 2^(8n)-1
                    <cref source="Sharon">2^128-1 for a 256-bit EC</cref>
                    </t>
                    <t>
                    s - integer between 0 and 2^(16n)-1
                    <cref source="Sharon">2^256-1 for a 256-bit EC</cref>
                    </t>
                </list>
            </t>
            <t>
                Steps:
                <list style="numbers">
                    <t>let gamma', c', s' be pi split after 2n+1-th and 3n+1-th octet
                    <cref source="Sharon">"split after 33-rd and 49-th octet" for a 256-bit EC</cref>
                    </t>
                    <t>gamma = OS2ECP(gamma')</t>
                    <t>c = OS2IP(c')</t>
                    <t>s = OS2IP(s')</t>
                    <t>Output gamma, c, and s</t>
                </list>
            </t>
        </section>

        </section><!-- Auxiliary Functions -->

        <section title="EC-VRF Ciphersuites">
        
        <t>[Seeking feedback on this section!]</t>
        
        <t>This document defines SHA256-P256-EC-VRF as follows: 
        <list style="symbols">
        <t>
            The EC group G is the NIST-P256 elliptic curve, with curve parameters
            as specified in <xref target="FIPS-186-3"></xref> (Section D.1.2.3) 
            and <xref target="RFC5114"></xref>  (Section 2.6).  For this group,
            the length in octets of a single coordinate of an EC point is 
            2n = 32.
        </t>
        
        <t>
            EC points are represented using point compression, as specified in 
            TBD. <cref source="Sharon">Dimitris and Jan to fill this in!</cref>
        </t>
        <t>
            The hash function Hash is SHA-256 as specified in <xref target="RFC6234"/>.
        </t>
        </list>
        </t>
        
        
        
        <t>This document defines SHA256-ED25519-EC-VRF as follows: 
        <list style="symbols">
        <t>
            The EC group G is the Ed25519
            elliptic curve with parameters defined in 
            <xref target="RFC7748"></xref> (Section 4.1).      
            For this group,
            the length in octets of a single coordinate of an EC point is 
            2n = 32.
        </t>
        <t>
            EC points are represented using point compression, as specified in 
            TBD. <cref source="Sharon">Dimitris and Jan to fill this in!</cref>
        </t>
        <t>
            The hash function Hash is SHA-256 as specified in <xref target="RFC6234"/>.
        </t>
        </list>
        </t>
   
        <t>[TODO: We could have an SHA256-Elligator-ED25519-EC-VRF 
        ciphersuite where the Elligator hash function is used for EC-VRF_hash-to-curve.
        Thoughts?]
        </t>
   
        <t>[TODO: Add an Ed448 ciphersuite?]</t>
   
        
        
        </section>
    </section>

    <section title="Security Considerations" anchor="securitycons">
    
    <t> aaaaaaaa </t>
    </section>

    <section title="Change Log">
        <t>
            Note to RFC Editor: if this document does not obsolete an existing RFC,
            please remove this appendix before publication as an RFC.
        </t>

        <t>
            <list>
                <t>
                    00 - Forked this document from draft-vcelak-nsec5-04. 
                    Cleaned up the definitions of VRF algorithms.
                    Added security definitions for VRF.
                    Parameterized EC-VRF so it could support curves other than 
                    P-256 and Ed25519. 
                </t>
            </list>
        </t>
    </section>

    <section title="Contributors">
        <t>
            This document would not be possible without help of
            Moni Naor (Weizmann Institute),
            Sachin Vasant (Cisco Systems),
            Leonid Reyzin (Boston University), and
            Asaf Ziv (Facebook).
        </t>
    </section>

</middle>

<back>
    <!-- References Section -->

<!--
     Section 4.7f of [RFC2223bis] specifies the requirements for the
     references sections.  In particular, there MUST be separate lists of
     normative and informative references, each in a separate section.
     The style SHOULD follow that of recently published RFCs.

     In general, each normative reference SHOULD reference the most recent
     version of the specification in question.
-->

    <references title="Normative References">
        &rfc2119;
        &rfc3447;
        &rfc5114;
        &rfc6234;
        &rfc7748;
        &rfc8080;
        &I-D.vcelak-nsec5;

        <reference anchor="FIPS-186-3">
            <front>
                <title>Digital Signature Standard (DSS)</title>
                <author><organization>National Institute for Standards and Technology</organization></author>
                <date year="2009" month="June" />
            </front>
            <seriesInfo name="FIPS" value="PUB 186-3" />
        </reference>

        <reference anchor="SECG1" target="http://www.secg.org/sec1-v2.pdf">
            <front>
                <title>SEC 1: Elliptic Curve Cryptography</title>
                <author><organization>Standards for Efficient Cryptography Group (SECG)</organization></author>
                <date year="2009" month="May" />
            </front>
            <seriesInfo name="Version" value="2.0" />
        </reference>

    </references>

    <references title="Informative References">

        <reference anchor="nsec5ecc">
            <front>
                <title>NSEC5 from Elliptic Curves</title>
                <author initials="D." surname="Papadopoulos"><organization /></author>
                <author initials="D." surname="Wessels"><organization /></author>
                <author initials="S." surname="Huque"><organization /></author>
                <author initials="J." surname="Vcelak"><organization /></author>
                <author initials="M." surname="Naor"><organization /></author>
                <author initials="L." surname="Reyzin"><organization /></author>
                <author initials="S." surname="Goldberg"><organization /></author>
                <date year="2017" month="February" />
            </front>
            <seriesInfo name="in" value="ePrint Cryptology Archive 2017/099" />
        </reference>

        <reference anchor="MRV99">
            <front>
                <title>Verifiable Random Functions</title>
                <author initials="S." surname="Michali"><organization /></author>
                <author initials="M." surname="Rabin"><organization /></author>
                <author initials="S." surname="Vadhan"><organization /></author>
                <date year="1999" />
            </front>
            <seriesInfo name="in" value="FOCS" />
        </reference>

        <reference anchor="CP92">
            <front>
                <title>Wallet databases with observers</title>
                <author initials="D." surname="Chaum"><organization /></author>
                <author initials="C." surname="Pederson"><organization /></author>
                <date year="1992" />
            </front>
            <seriesInfo name="in" value="FOCS" />
        </reference>


    </references>


    <section title="Open Issues">
        <t>
            Note to RFC Editor: please remove this appendix before publication as an RFC.
        </t>

        <t>
            <list style="numbers">
                <t>Open issues</t>
            </list>
        </t>
    </section>
  </back>
</rfc>
<!-- vim: et ts=4 sts=4 sw=4 colorcolumn=100 spell :
-->
