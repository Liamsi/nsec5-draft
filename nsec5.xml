<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY rfc1034 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.1034.xml">
<!ENTITY rfc1035 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.1035.xml">
<!ENTITY rfc2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY rfc2136 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2136.xml">
<!ENTITY rfc2181 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2181.xml">
<!ENTITY rfc2308 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2308.xml">
<!ENTITY rfc4033 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4033.xml">
<!ENTITY rfc4034 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4034.xml">
<!ENTITY rfc4035 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4035.xml">
<!ENTITY rfc4648 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4648.xml">
<!ENTITY rfc5114 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5114.xml">
<!ENTITY rfc5155 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5155.xml">
<!ENTITY rfc6234 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6234.xml">
<!ENTITY rfc6605 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6605.xml">
<!ENTITY rfc6781 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6781.xml">
<!ENTITY rfc7129 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7129.xml">
<!ENTITY rfc7719 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7719.xml">
<!ENTITY rfc7748 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7748.xml">
<!ENTITY rfc8080 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.8080.xml">
<!ENTITY I-D.gieben-nsec4 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.gieben-nsec4.xml">
]>
<?rfc toc="yes"?>
<?rfc symrefs="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<?rfc strict="no"?>
<?rfc rfcedstyle="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>

<rfc category="std" docName="draft-vcelak-nsec5-04" ipr="trust200902">
    <front>
        <title abbrev="NSEC5">NSEC5, DNSSEC Authenticated Denial of Existence</title>

        <author fullname="Jan Vcelak" initials="J." surname="Vcelak">
            <organization>CZ.NIC</organization>
            <address>
                <postal>
                    <street>Milesovska 1136/5</street>
                    <city>Praha</city>
                    <code>130 00</code>
                    <country>CZ</country>
                </postal>
                <email>jan.vcelak@nic.cz</email>
            </address>
        </author>

        <author fullname="Sharon Goldberg" initials="S." surname="Goldberg">
            <organization>Boston University</organization>
            <address>
                <postal>
                    <street>111 Cummington St, MCS135</street>
                    <city>Boston</city>
                    <region>MA</region>
                    <code>02215</code>
                    <country>USA</country>
                </postal>
                <email>goldbe@cs.bu.edu</email>
            </address>
        </author>

        <author fullname="Dimitrios Papadopoulos" initials="D." surname="Papadopoulos">
            <organization>University of Maryland</organization>
            <address>
                <postal>
                    <street>8223 Paint Branch Dr</street>
                    <city>College Park</city>
                    <region>MD</region>
                    <code>20740</code>
                    <country>USA</country>
                </postal>
                <email>dipapado@umd.edu</email>
            </address>
        </author>


        
        
        <author fullname="Shumon Huque" initials="S." surname="Huque">
            <organization>Salesforce</organization>
            <address>
                <postal>
                    <street>2550 Wasser Terrace</street>
                    <city>Herndon</city>
                    <region>VA</region>
                    <code>20171</code>
                    <country>USA</country>
                </postal>
                <email>shuque@gmail.com</email>
            </address>
        </author>

        <author fullname="David C Lawrence" initials="D.C." surname="Lawrence">
            <organization>Akamai Technologies</organization>
            <address>
                <postal>
                    <street>150 Broadway</street>
                    <city>Boston</city>
                    <region>MA</region>
                    <code>02142-1054</code>
                    <country>USA</country>
                </postal>
                <email>tale@akamai.com</email>
            </address>
        </author>

        <date year="2017" />

        <!-- <workgroup></workgroup> -->

        <keyword>DNS</keyword>
        <keyword>DNSSEC</keyword>
        <keyword>NSEC</keyword>
        <keyword>authenticated denial</keyword>

    <abstract>

        <!--
            Keep it brief. Remember, don't put any citations in the abstract, and expand your acronyms.
        <-->

        <t>
            The Domain Name System Security (DNSSEC) Extensions introduced the NSEC resource
            record (RR) for authenticated denial of existence and the NSEC3 RR for hashed
            authenticated denial of existence.  This document introduces NSEC5
            as an alternative mechanism for DNSSEC authenticated denial of existence. 
            NSEC5 uses verifiable random functions (VRFs) to prevent
            offline enumeration of zone contents. NSEC5 also protects the integrity of the
            zone contents even if an adversary compromises one of the
            authoritative servers for the zone.  Integrity is
            preserved because NSEC5 does not require
            private zone-signing keys to be present on all authoritative servers
            for the zone, in contrast to DNSSEC online signing schemes like NSEC3
            White Lies.
        </t>

    </abstract>

</front>

<middle>
    <section title="Introduction">

        <section title="Rationale">

            <!--
                You can echo the abstract in the Introduction, providing citations here, but you
                should provide more than just the abstract.
            -->

            <t>
               NSEC5 provides an alternative mechanism for authenticated denial of
               existence for the DNS Security Extensions (DNSSEC). NSEC5 has two 
               key security properties. 
               
               First, NSEC5 protects the integrity of the zone contents 
               even if an adversary compromises one of the 
               authoritative servers for the zone.   
               
               Second, NSEC5 prevents offline zone enumeration, where 
               an adversary makes a small number of online DNS queries 
                and then processes them offline in order to learn all of
                the names in a zone. Zone enumeration can be used to
                identify routers, servers or other "things" that could 
                then be targeted in more complex attacks. An enumerated
                zone can also be a source of probable email addresses
                for spam, or as a "key for multiple WHOIS queries to
                reveal registrant data that many registries may have
                legal obligations to protect" <xref target="RFC5155" />. 
            </t>
        
            <t>
                All other DNSSEC mechanisms for authenticated denial of
                existence either fail to preserve integrity against a 
                compromised server, or fail to prevent offline zone 
                enumeration.  
           </t>
            
            
            <t>
                When offline signing with NSEC is used 
                <xref target="RFC4034" />, an NSEC chain of 
                all existing domain names in the zone is constructed and signed
                offline. The chain 
                is made of resource records (RRs), where each RR 
                represents two consecutive domain
                names in canonical order present in the zone. 
                The authoritative server proves the non-existence of 
                a name by presenting a signed NSEC RR which covers the name.  
                Because the authoritative server does not need not 
                to know the private zone-signing key,  the integrity of the 
                zone is protected even if the server is compromised.
                However, the NSEC chain allows for easy zone enumeration:
                N queries to the server suffice to learn all N names in 
                the zone (see e.g., <xref target="nmap-nsec-enum"/>,
                <xref target="nsec3map"/>, and
                <xref target="ldns-walk"/>).
            </t>
            
            <t>
                When offline signing with NSEC3 is used <xref target="RFC5155" />, 
                the original names in the NSEC chain are replaced by their cryptographic 
                hashes. Offline signing ensures that NSEC3 preserves integrity
                even if an authoritative server is compromised. However, 
                offline zone enumeration is still possible with 
                NSEC3
                (see e.g., <xref target="nsec3walker" />, <xref target="nsec3gpu" />), 
                and is part of standard network reconnaissance tools 
                (e.g., <xref target="nmap-nsec3-enum"/>, <xref target="nsec3map"/>). 
            </t>
            
            <t>
                When online signing is used, the authoritative server holds the private 
                zone-signing key and uses this key to synthesize 
                NSEC or NSEC3 responses on the fly 
                (e.g. 
                NSEC3 White Lies (NSEC3-WL) or Minimally-Covering NSEC,
                both described in <xref target="RFC7129" />).  Because the 
                synthesized response only contains information 
                about the queried name (but not about any other name in 
                the zone), offline zone enumeration is not possible.
                However, because the authoritative server 
                holds the private zone-signing key, integrity is lost if 
                the authoritative server is compromised.
            </t>
            
                <texttable>
                    <ttcol>Scheme</ttcol>
                    <ttcol align="right">Integrity vs network attacks?</ttcol>
                    <ttcol align="right">Integrity vs compromised auth. server?</ttcol>
                    <ttcol align="right">Prevents offline zone enumeration?</ttcol>
                    <ttcol align="right">Online crypto?</ttcol>
                    <c>Unsigned</c> <c>NO</c> <c>NO</c> <c>YES</c> <c>NO</c>
                    <c>NSEC</c> <c>YES</c> <c>YES</c> <c>NO</c> <c>NO</c>
                    <c>NSEC3</c> <c>YES</c> <c>YES</c> <c>NO</c> <c>NO</c>
                    <c>NSEC3-WL</c> <c>YES</c> <c>NO</c> <c>YES</c>  <c>YES</c>
                    <c>NSEC5</c> <c>YES</c>  <c>YES</c>  <c>YES</c> <c>YES</c>
                </texttable>


            
            <t>
                NSEC5 prevents offline zone enumeration and also protects integrity 
                even if a zone's authoritative server is compromised. 
                To do this, NSEC5 replaces the unkeyed cryptographic hash 
                function used in NSEC3 with a verifiable random function 
                (VRF) <xref target="MRV99" />.  
                A VRF is the public-key version of a keyed 
                cryptographic hash.  Only the holder of the private VRF key 
                can compute the hash, but anyone with public VRF key can 
                verify the correctness of the hash.
            </t>
           
           <t> 
                The public VRF key is distributed in an NSEC5KEY RR,
                similar to a DNSKEY RR,
                and is used to verify NSEC5 hash values.  The private VRF key
                is present on all authoritative servers for the zone, and is 
                used to compute hash values. For every query that elicits 
                a negative response, the authoritative server hashes the 
                query on the fly using the private VRF key, and also returns 
                the corresponding precomputed NSEC5 record(s). In contrast
                to the online signing approach <xref target="RFC7129" />,
                the private key that is present 
                on all authoritative servers for NSEC5 cannot be used to modify 
                the zone contents.
           </t>
                
           <t>
                Like online signing approaches, NSEC5 requires the authoritative server
                to perform online public key cryptographic operations for
                every query eliciting a denying response.
                This is necessary; <xref target="nsec5" />  proved that 
                online cryptography is required to prevent offline zone enumeration 
                while still protecting the integrity of zone contents against network 
                attacks.   
           </t>
         
           <t>
                NSEC5 is not intended to replace NSEC or NSEC3. It is an
                alternative mechanism for authenticated denial of existence.
                This document specifies NSEC5 based on the FIPS 186-3 P-256 elliptic
                curve and on the Ed25519 elliptic curve. A formal cryptographic 
                proof of security for elliptic curve (EC) NSEC5 is in 
                <xref target="nsec5ecc"/>.
           </t>
           
         
        </section>

        <section title="Requirements">
            <t>
                The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
                "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
                document are to be interpreted as described in
                <xref target="RFC2119" />.
            </t>
        </section>

        <section title="Terminology">

            <t>
                The reader is assumed to be familiar with the basic DNS and DNSSEC concepts
                described in
                <xref target="RFC1034" />,
                <xref target="RFC1035" />,
                <xref target="RFC4033" />,
                <xref target="RFC4034" />, and
                <xref target="RFC4035" />; subsequent RFCs that update them in
                <xref target="RFC2136" />,
                <xref target="RFC2181" />,
                <xref target="RFC2308" />,
                <xref target="RFC5155" />, and
                <xref target="RFC7129" />; and DNS terms in
                <xref target="RFC7719" />.
            </t>

            <t>
                The following terminology is used through this document:
            </t>

            <t>
                <list style="hanging">
                    <t hangText="Base32hex:">
                        The "Base 32 Encoding with Extended Hex Alphabet" as specified
                        in <xref target="RFC4648" />. The padding characters ("=") are not
                        used in the NSEC5 specification.
                    </t>
                    <t hangText="Base64:">
                        The "Base 64 Encoding" as specified in <xref target="RFC4648" />.
                    </t>
                    <t hangText="QNAME:">
                        The domain name being queried (query name).
                    </t>
                    <t hangText="Private NSEC5 key:">
                        The private key for the verifiable random function (VRF). 
                    </t>
                    <t hangText="Public NSEC5 key:">
                        The public key for the VRF. 
                    </t>
                    <t hangText="NSEC5 proof:">
                        A VRF proof. The holder of 
                        the private NSEC5 key (e.g., authoritative server) can 
                        compute the NSEC5 proof for an input domain name. 
                        Anyone who knows the public VRF key can verify 
                        that the NSEC5 proof corresponds to the input domain name. 
                    </t>
                    <t hangText="NSEC5 hash:">
                        A cryptographic digest of an NSEC5 proof. If the NSEC5
                        proof is known, anyone can compute its corresponding NSEC5 hash.
                    </t>
                    <t hangText="NSEC5 algorithm:">
                        A triple of VRF algorithms that compute an NSEC5 proof,
                        verify an NSEC5 proof, and process an NSEC5 proof to 
                        obtain its NSEC5 hash.
                    </t>
                </list>
            </t>
        </section>

    </section>

    <section title="Backward Compatibility">
        <t>
            The specification describes a protocol change that is not backward compatible
            with <xref target="RFC4035" /> and <xref target="RFC5155" />. An NSEC5-unaware
            resolver will fail to validate responses introduced by this document.
        </t>

        <t>
            To prevent NSEC5-unaware resolvers from attempting to validate the responses, new
            DNSSEC algorithms identifiers are introduced in 
            <xref target="iana_considerations" /> which alias existing
            algorithm numbers. The zones signed according to this specification MUST use only
            these algorithm identifiers, thus NSEC5-unaware resolvers will treat the zone as
            insecure.
        </t>

    </section>

    <section title="How NSEC5 Works">
    
        <!--<t>[TODO: This section to be updated to be consistent with the VRF I-D.]
        </t>-->
    
        <t>
                With NSEC5, the original domain name is hashed using the VRF
                using the following steps:
        </t>

        <t>
            <list style="numbers">
                <t>
                    The domain name is processed using a VRF keyed with the 
                    private NSEC5 key to obtain the NSEC5 proof.
                    Anyone who knows the public NSEC5 key, normally
                    acquired via
                    an NSEC5KEY RR, can verify that a given NSEC5 proof 
                    corresponds to a given domain name.
                </t>
                <t>
                    The NSEC5 proof is then processed using a publicly-computable
                    VRF proof-to-hash function to obtain the NSEC5 hash.
                    The NSEC5 hash can be computed by anyone who knows the 
                    input NSEC5 proof.
                </t>
            </list>
        </t>

        <t>
            The NSEC5 hash determines the position of a domain name 
            in an NSEC5 chain. 
        </t>
        
        <t>
            To sign a zone, the private NSEC5 key is used to compute the
            NSEC5 hashes for each name in the zone. These NSEC5 hashes are sorted in  
            canonical order <xref target="RFC4034"/> , and each consecutive pair forms an NSEC5 RR. 
            Each NSEC5 RR is signed offline using the private zone-signing key. 
            The resulting signed chain of NSEC5 RRs is provided to all 
            authoritative servers for the zone, along with the private
            NSEC5 key. 
        </t>

        <t>
            To prove non-existence of a particular domain name in 
            response to a query, the server uses the private NSEC5 key 
            to compute the NSEC5 proof and NSEC5 hash corresponding to 
            the queried name. 
            The server then identifies the NSEC5 RR that covers the NSEC5 hash.
            The server then responds with 
            the NSEC5 RR and its corresponding RRSIG signature RRset,
            as well as a synthesized NSEC5PROOF RR that contains the 
            NSEC5 proof corresponding to the queried name. 
        </t>

        <t>
            To validate the response,
            the client verifies the following items:
        </t>    
        <t>
            <list style="symbols">
            <t> 
            The client uses the public NSEC5 key, normally acquired from the NSEC5KEY RR,
            to verify that the NSEC5 proof in the NSEC5PROOF RR
            corresponds to the queried name. 
            </t>
            
            <t>
            The client uses the VRF proof-to-hash function to compute
            the NSEC5 hash from the NSEC5 proof in the NSEC5PROOF RR.
            The client verifies that the NSEC5 hash is
            covered by the NSEC5 RR. 
            </t>
            <t>
            The client verifies that the NSEC5 RR is validly signed by the
            RRSIG RRset.
            </t>
            </list>
        </t>

    </section>

    <section title="NSEC5 Algorithms">

        <t>
            The algorithms used for NSEC5 authenticated denial are independent of the algorithms
            used for DNSSEC signing. An NSEC5 algorithm defines how the NSEC5 proof and the
            NSEC5 hash are computed and validated.
        </t>

        <t>
            The input for the NSEC5 proof computation is an RR owner name in
            <xref target="RFC4034"/> canonical wire format followed by
            a private NSEC5 key.  The output is an octet string.
        </t>

        <t>
            The input for the NSEC5 hash computation is the corresponding NSEC5 proof; the output
            is an octet string.
        </t>


    <!-- REMOVE RSA NSEC5 FROM THIS DRAFT!
        <t>
            This document defines RSAFDH-SHA256-SHA256 NSEC5 algorithm as follows:
        </t>

        <t>
            <list style="symbols">
                <t>
                    NSEC5 proof is computed using an RSA based Full Domain Hash (FDH) signature
                    with SHA-256 hash function used internally for input preprocessing. The
                    signature and verification are formally specified in <xref target="fdh" />.
                </t>
                <t>
                    NSEC5 hash is computed by hashing the NSEC5 proof with the SHA-256 hash
                    function as specified in <xref target="RFC6234" />.
                </t>
                <t>
                    The public key format to be used in NSEC5KEY RR is defined in Section 2 of
                    <xref target="RFC3110" /> and thus is the same as the format used to store
                    RSA public keys in DNSKEY RRs.
                </t>
            </list>
        </t>
-->
        <t>
            This document defines EC-P256-SHA256 NSEC5 algorithm as follows:
        </t>

        <t>
            <list style="symbols">
                <t>
                    The NSEC5 proof is computed using an Elliptic Curve VRF with
                    FIPS 186-3 P-256 curve.
                    The proof computation and verification, and the proof-to-hash
                    function are formally specified in
                    <xref target="ecvrf" />.
                    The curve parameters are specified in
                    <xref target="FIPS-186-3" /> (Section D.1.2.3) and
                    <xref target="RFC5114" /> (Section 2.6).
                </t>
                <t>
                    The NSEC5 hash is the x-coordinate of the group element gamma
                    from the NSEC5 proof (specified in <xref target="ecvrf" />),
                    encoded as a 32-octet unsigned integer
                    in network byte order. In practice, the hash is a substring
                    of the proof ranging from 2nd through 33th octet of the proof,
                    inclusive.
                </t>
                <t>
                    The public key format to be used in the NSEC5KEY RR is defined in Section 4 of
                    <xref target="RFC6605" /> and thus is the same as the format used to store
                    ECDSA public keys in DNSKEY RRs.
                </t>
            </list>
        </t>

        <t>
            This document defines EC-ED25519-SHA256 NSEC5 algorithm as follows:
        </t>

        <t>
            <list style="symbols">
                <t>
                    The NSEC5 proof and NSEC5 hash are the same as with EC-P256-SHA256 
                    but using Ed25519
                    elliptic curve with parameters defined in <xref target="RFC7748" />
                    Section 4.1.
                </t>
                <!--<t>
                    The NSEC5 hash is the same as with EC-P256-SHA256.
                </t>-->
                <t>
                    The public key format to be used in the NSEC5KEY RR is defined in Section 3 of
                    <xref target="RFC8080" /> and thus is the same as the
                    format used to store Ed25519 public keys in DNSKEY RRs.
                </t>
            </list>
        </t>
    </section>

    <section title="The NSEC5KEY Resource Record">

        <t>
            The NSEC5KEY RR stores a public NSEC5 key. The key allows clients to
            validate an NSEC5 proof sent by a server.
        </t>

        <section title="NSEC5KEY RDATA Wire Format">
            <t>
                The RDATA for NSEC5KEY RR is as shown below:
            </t>

            <figure align="center">
                <artwork><![CDATA[
                     1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Algorithm   |                  Public Key                   /
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                ]]></artwork>
            </figure>

            <t>
                Algorithm is a single octet identifying the NSEC5 algorithm.
            </t>
            <t>
                Public Key is a variable-sized field holding public key material for NSEC5
                proof verification.
            </t>
        </section>

        <section title="NSEC5KEY RDATA Presentation Format">
            <t>
                The presentation format of the NSEC5KEY RDATA is as follows:
            </t>

            <t>
                The Algorithm field is represented as an unsigned decimal integer.
            </t>

            <t>
                The Public Key field is represented in Base64 encoding. Whitespace is allowed
                within the Base64 text.
            </t>
        </section>
    </section>

    <section title="The NSEC5 Resource Record">
        <t>
            The NSEC5 RR provides authenticated denial of existence
            for an RRset or domain name. One NSEC5 RR
            represents one piece of an NSEC5 chain, proving existence
            of the owner name and non-existence of other domain names
            in the part of the hashed domain space covered until the
            next owner name hashed in the RDATA.
        </t>

        <section title="NSEC5 RDATA Wire Format">
            <t>
                The RDATA for NSEC5 RR is as shown below:
            </t>

            <figure align="center">
                <artwork><![CDATA[
                     1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|            Key Tag            |     Flags     |  Next Length  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                     Next Hashed Owner Name                    /
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
/                         Type Bit Maps                         /
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                ]]></artwork>
            </figure>

            <t>
                The Key Tag field contains the key tag value of the NSEC5KEY RR that validates the
                NSEC5 RR, in network byte order. The value is computed from the NSEC5KEY RDATA
                using the same algorithm, which is used to compute key tag values for DNSKEY RRs.
                The algorithm is defined in <xref target="RFC4034" />.
            </t>
            <t>
                The Flags field is a single octet. The meaning of individual bits of the field is
                defined in <xref target="nsec5_flags" />.
            </t>
            <t>
                The Next Length field is an unsigned single octet specifying the length of the Next Hashed
                Owner Name field in octets.
            </t>
            <t>
                The Next Hashed Owner Name field is a sequence of binary octets. It contains an NSEC5
                hash of the next domain name in the NSEC5 chain.
            </t>
            <t>
                Type Bit Maps is a variable-sized field encoding RR types present at the original
                owner name matching the NSEC5 RR. The format of the field is equivalent to the
                format used in the NSEC3 RR, described in <xref target="RFC5155" />.
            </t>
        </section>

        <section title="NSEC5 Flags Field" anchor="nsec5_flags">
            <t>
                The following one-bit NSEC5 flags are defined:
            </t>

            <figure align="center">
                <artwork><![CDATA[
 0 1 2 3 4 5 6 7
+-+-+-+-+-+-+-+-+
|           |W|O|
+-+-+-+-+-+-+-+-+
                ]]></artwork>
            </figure>

            <t>
                <list>
                    <t>O - Opt-Out flag</t>
                    <t>W - Wildcard flag</t>
                </list>
            </t>

            <t>
                All the other flags are reserved for future use and MUST be zero.
            </t>

            <t>
                The Opt-Out flag has the same semantics as in NSEC3. The definition and
                considerations in <xref target="RFC5155" /> are valid, except that NSEC3
                is replaced by NSEC5.
            </t>

            <t>
                The Wildcard flag indicates that a wildcard synthesis is possible at the
                original domain name level (i.e., there is a wildcard node immediately
                descending from the immediate ancestor of the original domain name). 
                The purpose of the Wildcard flag is to reduce the maximum number of
                RRs required for an authenticated denial of existence proof, as
                originally described in <xref target="I-D.gieben-nsec4" /> Section 7.2.1.
            </t>
        </section>

        <section title="NSEC5 RDATA Presentation Format">
            <t>
                The presentation format of the NSEC5 RDATA is as follows:
            </t>

            <t>
                The Key Tag field is represented as an unsigned decimal integer.
            </t>

            <t>
                The Flags field is represented as an unsigned decimal integer.
            </t>

            <t>
                The Next Length field is not represented.
            </t>

            <t>
                The Next Hashed Owner Name field is represented as a sequence
                of case-insensitive Base32hex digits without any whitespace and
                without padding.
            </t>

            <t>
                The Type Bit Maps representation is equivalent to the representation
                used in NSEC3 RR, described in <xref target="RFC5155" />.
            </t>
        </section>
    </section>

    <section title="The NSEC5PROOF Resource Record">
        <t>
            The NSEC5PROOF record is not to be included in the zone file.
            The NSEC5PROOF record contains the NSEC5 proof, proving the 
            position of the owner name in an
            NSEC5 chain.
        </t>

        <section title="NSEC5PROOF RDATA Wire Format" anchor="nsec5proof_rdata">
            <t>
                The RDATA for NSEC5PROOF is shown below:
            </t>

            <figure align="center">
                <artwork><![CDATA[
                     1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|            Key Tag            |        Owner Name Hash        /
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                ]]></artwork>
            </figure>

            <t>
                Key Tag field contains the key tag value of the NSEC5KEY RR that validates
                the NSEC5PROOF RR, in network byte order.
            </t>
            <t>
                Owner Name Hash is a variable-sized sequence of binary octets encoding the NSEC5
                proof of the owner name of the RR.
            </t>
        </section>

        <section title="NSEC5PROOF RDATA Presentation Format">
            <t>
                The presentation format of the NSEC5PROOF RDATA is as follows:
            </t>

            <t>
                The Key Tag field is represented as an unsigned decimal integer.
            </t>

            <t>
                The Owner Name Hash is represented in Base64 encoding. Whitespace
                is allowed within the Base64 text.
            </t>
        </section>
    </section>

    <section title="Types of Authenticated Denial of Existence with NSEC5" anchor="nsec5_proofs">

        <t>
            This section summarizes all possible types of authenticated denial of existence.
            For each type the following lists are included:
        </t>

        <t>
            <list style="numbers">
                <t>
                    Facts to prove: the minimum amount of information that an authoritative server
                    must provide to a client to assure the client that the response content is
                    valid.
                </t>
                <t>
                    Authoritative server proofs: the names for which the NSEC5PROOF RRs are synthesized
                    and added into the response along the NSEC5 RRs matching or covering each such
                    name. These records together prove the listed facts.
                </t>
                <t>
                    Validator checks: the individual checks that a validating server is required to
                    perform on a response. The response content is considered valid only if all
                    of the checks pass.
                </t>
            </list>
        </t>

        <t>
            If NSEC5 is said to match a domain name, the owner name of the NSEC5 RR has to be
            equivalent to an NSEC5 hash of that domain name. If an NSEC5 RR is said to cover
            a domain name, the NSEC5 hash of the domain name must sort in canonical order between that
            NSEC5 RR's Owner Name and Next Hashed Owner Name.
        </t>

        <section title="Name Error Responses">

            <t>
                Facts to prove:
                <list>
                    <t>No RRset matching the QNAME exists.</t>
                    <t>No RRset matching the QNAME via wildcard expansion exists.</t>
                    <t>The QNAME does not fall into a delegation.</t>
                    <t>The QNAME does not fall into a DNAME redirection.</t>
                </list>
            </t>

            <t>
                Authoritative server proofs:
                <list>
                    <t>NSEC5PROOF for closest encloser and matching NSEC5 RR.</t>
                    <t>NSEC5PROOF for next closer name and covering NSEC5 RR.</t>
                </list>
            </t>

            <t>
                Validator checks:
                <list>
                    <t>Closest encloser is in the zone.</t>
                    <t>Closest encloser has the Wildcard flag cleared.</t>
                    <t>Closest encloser does not have NS without SOA in the Type Bit Map.</t>
                    <t>Closest encloser does not have DNAME in the Type Bit Maps.</t>
                    <t>Next closer name is derived correctly.</t>
                    <t>Next closer name is not in the zone.</t>
                </list>
            </t>

        </section>

        <section title="No Data Responses">

            <t>
                The processing of a No Data response for DS QTYPE differs if the Opt-Out is in
                effect. For DS QTYPE queries, the validator has two possible checking paths.
                The correct path can be simply decided by inspecting if the NSEC5 RR in the
                response matches the QNAME.
            </t>

            <t>
                Note that the Opt-Out is valid only for DS QTYPE queries.
            </t>

            <section title="No Data Response, Opt-Out Not In Effect">

                <t>
                    Facts to prove:
                    <list>
                        <t>An RRset matching the QNAME exists.</t>
                        <t>No QTYPE RRset matching the QNAME exists.</t>
                        <t>No CNAME RRset matching the QNAME exists.</t>
                    </list>
                </t>

                <t>
                    Authoritative server proofs:
                    <list>
                        <t>NSEC5PROOF for the QNAME and matching NSEC5 RR.</t>
                    </list>
                </t>

                <t>
                    Validator checks:
                    <list>
                        <t>The QNAME is in the zone.</t>
                        <t>The QNAME does not have QTYPE in the Type Bit Map.</t>
                        <t>The QNAME does not have CNAME in the Type Bit Map.</t>
                    </list>
                </t>

            </section>

            <section title="No Data Response, Opt-Out In Effect">

                <t>
                    Facts to prove:
                    <list>
                        <t>The delegation is not covered by the NSEC5 chain.</t>
                    </list>
                </t>

                <t>
                    Authoritative server proofs:
                    <list>
                        <t>NSEC5PROOF for closest provable encloser and matching NSEC5 RR.</t>
                    </list>
                </t>

                <t>
                    Validator checks:
                    <list>
                        <t>Closest provable encloser is in zone.</t>
                        <t>Closest provable encloser covers (not matches) the QNAME.</t>
                        <t>Closest provable encloser has the Opt-Out flag set.</t>
                    </list>
                </t>

            </section>

        </section>

        <section title="Wildcard Responses">

            <t>
                Facts to prove:
                <list>
                    <t>No RRset matching the QNAME exists.</t>
                    <t>No wildcard closer to the QNAME exists.</t>
                </list>
            </t>

            <t>
                Authoritative server proofs:
                <list>
                    <t>NSEC5PROOF for next closer name and covering NSEC5 RR.</t>
                </list>
            </t>
            <t>
                Validator checks:
                <list>
                    <t>Next closer name is derived correctly.</t>
                    <t>Next closer name is not in the zone.</t>
                </list>
            </t>

        </section>

        <section title="Wildcard No Data Responses">

            <t>
                Facts to prove:
                <list>
                    <t>No RRset matching the QNAME exists.</t>
                    <t>No QTYPE RRset exists at the wildcard matching the QNAME.</t>
                    <t>No CNAME RRset exists at the wildcard matching the QNAME.</t>
                    <t>No wildcard closer to the QNAME exists.</t>
                </list>
            </t>

            <t>
                Authoritative server proofs:
                <list>
                    <t>NSEC5PROOF for source of synthesis (i.e., wildcard at closest encloser) and
                        matching NSEC5 RR.</t>
                    <t>NSEC5PROOF for next closer name and covering NSEC5 RR.</t>
                </list>
            </t>

            <t>
                Validator checks:
                <list>
                    <t>Source of synthesis matches the QNAME.</t>
                    <t>Source of synthesis does not have QTYPE in the Type Bit Map.</t>
                    <t>Source of synthesis does not have CNAME in the Type Bit Map.</t>
                    <t>Next closer name is derived correctly.</t>
                    <t>Next closer name is not in the zone.</t>
                </list>
            </t>

        </section>
    </section>

    <section title="Authoritative Server Considerations">

        <section title="Zone Signing" anchor="zone_signing">
            <t>
                Zones using NSEC5 MUST satisfy the same properties as described in Section 7.1
                of <xref target="RFC5155" />, with NSEC3 replaced by NSEC5. In addition, the
                following conditions MUST be satisfied as well:
            </t>

            <t>
                <list style="symbols">
                    <t>
                        If the original owner name has a wildcard label immediately descending
                        from the original owner name, the corresponding NSEC5 RR MUST have the
                        Wildcard flag set in the Flags field. Otherwise, the flag MUST be cleared.
                    </t>
                    <t>
                        The zone apex MUST include an NSEC5KEY RRset containing a NSEC5 public
                        key allowing verification of the current NSEC5 chain.
                    </t>
                </list>
            </t>



            <t>
                The following steps describe one possible method to properly add required NSEC5
                related records into a zone. This is not the only such existing method.
            </t>

            <t>
                <list style="numbers">
                    <t>
                        Select an algorithm for NSEC5.  Generate the public and private NSEC5 keys.
                    </t>
                    <t>
                        Add a NSEC5KEY RR into the zone apex containing the public NSEC5 key.
                    </t>
                    <t>
                        For each unique original domain name in the zone and each empty
                        non-terminal, add an NSEC5 RR. If Opt-Out is used, owner names of
                        unsigned delegations MAY be excluded.
                        <list style="letters">
                            <t>
                                The owner name of the NSEC5 RR is the NSEC5 hash of the
                                original owner name encoded in Base32hex without padding,
                                prepended as a single label to the zone name.
                            </t>
                            <t>
                                Set the Key Tag field to be the key tag corresponding
                                to the public NSEC5 key.
                            </t>
                            <t>
                                Clear the Flags field. If Opt-Out is being used, set the Opt-Out
                                flag. If there is a wildcard label directly descending from the
                                original domain name, set the Wildcard flag. Note that the
                                wildcard can be an empty non-terminal (i.e., the wildcard synthesis
                                does not take effect and therefore the flag is not to be set).
                            </t>
                            <t>
                                Set the Next Length field to a value determined by the used
                                NSEC5 algorithm. Leave the Next Hashed Owner Name field blank.
                            </t>
                            <t>
                                Set the Type Bit Maps field based on the RRsets present at the
                                original owner name.
                            </t>
                        </list>
                    </t>
                    <t>
                        Sort the set of NSEC5 RRs into canonical order.
                    </t>
                    <t>
                        For each NSEC5 RR, set the Next Hashed Owner Name field by using the owner
                        name of the next NSEC5 RR in the canonical order. If the updated NSEC5 is
                        the last NSEC5 RR in the chain, the owner name of the first NSEC5 RR
                        in the chain is used instead.
                    </t>
                </list>
            </t>

            <t>
                The NSEC5KEY and NSEC5 RRs MUST have the same class as the zone SOA RR. Also
                the NSEC5 RRs SHOULD have the same TTL value as the SOA minimum TTL field.
            </t>

            <t>
                Notice that a use of Opt-Out is not indicated in the zone. This does not affect
                the ability of a server to prove insecure delegations. The Opt-Out MAY be part
                of the zone-signing tool configuration.
            </t>
            
            <section title="Precomputing Closest Provable Encloser Proofs" anchor="precompute">
            
            <t>The worst-case scenario when answering a negative
            query with NSEC5 requires authoritative server to respond with
            two NSEC5PROOF RRs and two NSEC5 RRs. Per 
            <xref target="nsec5_proofs"/>, one pair of NSEC5PROOF and 
            NSEC5 RRs corresponds to the closest provable encloser, and the other
            pair corresponds to the next closer name.  The NSEC5PROOF 
            corresponding to the next closer name MUST be computed on the fly by the 
            authoritative server when responding to the query. However, the
            NSEC5PROOF corresponding to the closest provable encloser MAY
            be precomputed and stored as part of zone signing.  
            </t>
            
            <t>Precomputing NSEC5PROOF RRs can halve the number of online 
            cryptographic computations required when responding to a negative 
            query. NSEC5PROOF RRs MAY be precomputed as part of zone signing
            as follows:  For each NSEC5 RR, compute an NSEC5PROOF RR corresponding to 
            the original owner name of the NSEC5 RR. The content of the 
            precomputed NSEC5PROOF record MUST be the 
            same as if the record was computed on the fly when serving the zone.
            NSEC5PROOF records are not part of the zone 
            and SHOULD be stored separately from the zone file. 
            </t>
                
            </section>
        </section>

        <section title="Zone Serving">
            <t>
                This specification modifies DNSSEC-enabled DNS responses generated by
                authoritative servers. In particular, it replaces use of NSEC or NSEC3 RRs in
                such responses with NSEC5 RRs and adds NSEC5PROOF RRs.
            </t>

            <t>
                According to the type of a response, an authoritative server MUST include NSEC5 RRs
                in the response, as defined in <xref target="nsec5_proofs" />. For each NSEC5 RR
                in the response, a corresponding RRSIG RRset and an NSEC5PROOF MUST be added
                as well. The NSEC5PROOF RR has its owner name set to the domain name 
                required according to <xref target="nsec5_proofs" />. The class and TTL of the 
                NSEC5PROOF RR MUST
                be the same as the class and TTL value of the corresponding NSEC5 RR. The RDATA
                payload of the NSEC5PROOF is set according to the description in <xref target="nsec5proof_rdata" />.
            </t>

            <t>
                Notice that the NSEC5PROOF owner name can be a wildcard (e.g., source of
                synthesis proof in wildcard No Data responses). The name also always matches
                the domain name required for the proof while the NSEC5 RR may only cover
                (not match) the name in the proof (e.g., closest encloser in Name Error responses).
            </t>

            <t>
                If NSEC5 is used, an answering server MUST use exactly one NSEC5 chain for
                one signed zone.
            </t>

            <t>
                NSEC5 MUST NOT be used in parallel with NSEC, NSEC3, or any other authenticated
                denial of  existence mechanism that allows for enumeration of zone contents, 
                as this would defeat a principal security goal of NSEC5.
            </t>

            <t>
                Similarly to NSEC3, the owner names of NSEC5 RRs are not represented in the
                NSEC5 chain and therefore NSEC5 records deny their own existence. The desired
                behavior caused by this paradox is the same as described in Section 7.2.8
                of <xref target="RFC5155" />.
            </t>

        </section>

        <section title="NSEC5KEY Rollover Mechanism">
            <t>
                Replacement of the NSEC5 key implies generating a new NSEC5 chain. The NSEC5KEY
                rollover mechanism is similar to "Pre-Publish Zone Signing Key Rollover" as
                specified in <xref target="RFC6781" />. The NSEC5KEY rollover MUST be
                performed as a sequence of the following steps:
            </t>

            <t>
                <list style="numbers">
                    <t>
                        A new public NSEC5 key is added into the NSEC5KEY RRset in the zone apex.
                    </t>
                    <t>
                        The old NSEC5 chain is replaced by a new NSEC5 chain constructed
                        using the new key. This replacement MUST happen as a single atomic
                        operation; the server MUST NOT be responding with RRs from
                        both the new and old chain at the same time.
                    </t>
                    <t>
                        The old public key is removed from the NSEC5KEY RRset in the zone apex.
                    </t>
                </list>
            </t>

            <t>
                The minimum delay between steps 1 and 2 MUST be the time it takes for the
                data to propagate to the authoritative servers, plus the TTL value of the old
                NSEC5KEY RRset.
            </t>

            <t>
                The minimum delay between steps 2 and 3 MUST be the time it takes for the
                data to propagate to the authoritative servers, plus the maximum zone TTL value
                of any of the data in the previous version of the zone.
            </t>
        </section>

        <section title="Secondary Servers">
            <t>
                This document does not define mechanism to distribute private NSEC5 keys.
                See <xref target="keyleak" />
                for security considerations for private NSEC5 keys.
            </t>
        </section>

        <section title="Zones Using Unknown NSEC5 Algorithms">
            <t>
                Zones that are signed with unknown NSEC5 algorithm or an unavailable 
                private NSEC5 key cannot be effectively served. Such zones SHOULD be rejected when
                loading and servers SHOULD respond with RCODE=2 (Server failure) when handling
                queries that would fall under such zones.
            </t>
        </section>

        <section title="Dynamic Updates">
            <t>
            A zone signed using NSEC5 MAY accept dynamic updates 
            <xref target="RFC2136" />.  The
            changes to the zone MUST be performed in a way that ensures that the zone
            satisfies the properties specified in <xref target="zone_signing" /> at any time.  The
            process described in <xref target="RFC5155" /> Section 7.5 describes how to handle
            the issues surrounding the handling of empty non-terminals as well as
            Opt-Out.
            </t>
            
            <t>
            It is RECOMMENDED that the server rejects all updates containing
            changes to the NSEC5 chain and its related RRSIG RRs, and performs itself
            any required alternations of the NSEC5 chain induced by the update.
            Alternatively, the server MUST verify that all the properties are
            satisfied prior to performing the update atomically.
            </t>
        </section>

    </section>

    <section title="Resolver Considerations">

        <t>
            The same considerations as described in Section 9 of <xref target="RFC5155" />
            for NSEC3 apply to NSEC5. In addition, as NSEC5 RRs can be validated only with
            appropriate NSEC5PROOF RRs, the NSEC5PROOF RRs MUST be all together cached and
            included in responses with NSEC5 RRs.
        </t>

    </section>

    <section title="Validator Considerations">
        <section title="Validating Responses">
            <t>
                The validator MUST ignore NSEC5 RRs with Flags field values other than the ones
                defined in <xref target="nsec5_flags" />.
            </t>

            <t>
                The validator MAY treat responses as bogus if the response contains NSEC5 RRs
                that refer to a different NSEC5KEY.
            </t>

            <t>
                According to a type of a response, the validator MUST verify all conditions defined
                in <xref target="nsec5_proofs" />. Prior to making decision based on the content
                of NSEC5 RRs in a response, the NSEC5 RRs MUST be validated.
            </t>

            <t>
                To validate a denial of existence, public NSEC5 keys for the zone are required in addition
                to DNSSEC public keys. Similarly to DNSKEY RRs, the NSEC5KEY RRs are present at
                the zone apex.
            </t>

            <t>
                The NSEC5 RR is validated as follows:

                <list style="numbers">
                    <t>
                        Select a correct public NSEC5 key to validate the NSEC5 proof. The Key Tag
                        value of the NSEC5PROOF RR must match with the key tag value computed
                        from the NSEC5KEY RDATA.
                    </t>
                    <t>
                        Validate the NSEC5 proof present in the NSEC5PROOF Owner Name Hash field
                        using the public NSEC5 key. If there are multiple NSEC5KEY RRs matching
                        the key tag, at least one of the keys must validate the NSEC5 proof.
                    </t>
                    <t>
                        Compute the NSEC5 hash value from the NSEC5 proof and check if the
                        response contains NSEC5 RR matching or covering the computed NSEC5 hash.
                        The TTL values of the NSEC5 and NSEC5PROOF RRs must be the same.
                    </t>
                    <t>
                        Validate the signature on the NSEC5 RR.
                    </t>
                </list>
            </t>

            <t>
                If the NSEC5 RR fails to validate, it MUST be ignored. If some of the conditions
                required for an NSEC5 proof are not satisfied, the response MUST be treated as
                bogus.
            </t>

            <t>
                Notice that determining the closest encloser and next closer name in NSEC5 is easier
                than in NSEC3. NSEC5 and NSEC5PROOF RRs are always present in pairs in responses
                and the original owner name of the NSEC5 RR matches the owner name of the
                NSEC5PROOF RR.
            </t>

        </section>

        <section title="Validating Referrals to Unsigned Subzones">
            <t>
                The same considerations as defined in Section 8.9 of <xref target="RFC5155" />
                for NSEC3 apply to NSEC5.
            </t>
        </section>

        <section title="Responses With Unknown NSEC5 Algorithms">
            <t>
                A validator MUST ignore NSEC5KEY RRs with unknown NSEC5 algorithms. The
                practical result of this is that zones signed with unknown algorithms will
                be considered bogus.
            </t>
        </section>
    </section>

    <section title="Special Considerations">

        <section title="Transition Mechanism">

            <t>
                [TODO: The following information will be covered.]

                <list style="symbols">
                    <t>Transition to NSEC5 from NSEC/NSEC3</t>
                    <t>Transition from NSEC5 to NSEC/NSEC3</t>
                    <t>Transition to new NSEC5 algorithms</t>
                </list>
            </t>

<!--
            <t>
                Quick notes on transition from NSEC/NSEC3 to NSEC5:
                <list style="numbers">
                    <t>Publish NSEC5KEY RR.</t>
                    <t>Wait for data propagation to slaves and cache expiration.</t>
                    <t>Instantly switch answering from NSEC/NSEC3 to NSEC5.</t>
                </list>
            </t>

            <t>
                Quick notes on transition from NSEC5 to NSEC/NSEC3:
                <list style="numbers">
                    <t>Instantly switch answering from NSEC5 to NSEC/NSEC3.</t>
                    <t>Wait for NSEC5 RRs expiration in caches.</t>
                    <t>Remove NSEC5KEY RR from the zone.</t>
                </list>
            </t>
-->

        </section>

        <section title="Private NSEC5 keys">
            <t>
                This document does not define a format to store private NSEC5 keys. Use of a
                standardized and adopted format is RECOMMENDED.  
            </t>

            <t>
                The private NSEC5 key MAY be shared between multiple zones, however a separate
                key is RECOMMENDED for each zone.
            </t>
        </section>

        <section title="Domain Name Length Restrictions">

            <t>
                NSEC5 creates additional restrictions on domain name lengths. In particular,
                zones with names that, when converted into hashed owner names, exceed the 255
                octet length limit imposed by <xref target="RFC1035" /> cannot use this
                specification.
            </t>

            <t>
                The actual maximum length of a domain name depends on the length of the zone
                name and the NSEC5 algorithm used.
            </t>

            <t>
                All NSEC5 algorithms defined in this document use 256-bit NSEC5 hash values.
                Such a value can be encoded in 52 characters in Base32hex without padding. When
                constructing the NSEC5 RR owner name, the encoded hash is prepended to the name
                of the zone as a single label which includes the length field of a single octet.

                The maximum length of the zone name in wire format
                using the 256-bit hash is
                therefore 202 octets (255 - 53).
            </t>

        </section>

    </section>

    <section  title="Implementation Status" anchor="implementation-status">

    <t>NSEC5 has been implemented for the Knot DNS authoritative server 
    (version 1.6.4) and the
    Unbound recursive server (version 1.5.9).
    The implementation did
    not introduce additional library dependencies; all cryptographic
    primitives are already present in OpenSSL
    v1.0.2j, which is used by both implementations. 
    The implementation supports the full spectrum of negative responses, 
    (i.e., NXDOMAIN, NODATA, Wildcard, Wildcard NODATA, and
    unsigned delegation). The implementation supports the 
    EC-P256-SHA256 algorithm. The code is deliberately modular, 
    so that the EC-ED25519-SHA256 algorithm could be implemented
    by using the Ed25519 elliptic curve <xref target="RFC8080" />
    as a drop-in replacement for the P256 elliptic curve. 
    The authoritative server implements
    the optimization from <xref target="precompute" />
    to precompute the NSEC5PROOF RRs
    matching each NSEC5 record. 
    </t>

    </section>


    <section title="Performance Considerations">
    
    <t>The performance of NSEC5 has been evaluated in <xref target="nsec5ecc"/>.
    </t>

    </section>


    <section title="Security Considerations">
    
        <section title="Zone Enumeration Attacks" anchor="zea">
        <t>
         NSEC5 is robust to zone enumeration via offline dictionary attacks by any
         attacker that does not know the private NSEC5 key.  Without the private NSEC5 key,
         that attacker cannot compute the NSEC5 proof that corresponds to a given domain name. 
         The only way it can learn the NSEC5 proof value for a domain name is by querying
         the authoritative server for that name. Without the NSEC5 proof value,
         the attacker cannot learn the NSEC5 hash value. Thus, even an attacker that
         collects the entire chain of NSEC5 RR for a zone cannot use offline attacks to
         "reverse" that NSEC5 hash values in these NSEC5 RR and thus learn which names are
         present in the zone.  A formal cryptographic proof of this property is in
         <xref target="nsec5" /> and <xref target="nsec5ecc" />.
        </t>
        </section>

        <section title="Compromise of the Private NSEC5 Key" anchor="keyleak">
        <t>
        NSEC5 requires authoritative servers to hold the private NSEC5 key, but
        not the private zone-signing keys or the private key-signing keys for the zone.
        </t>
        <t>
        The private NSEC5 key cannot be used to modify zone contents, because
        zone contents are signed using the private zone-signing key. 
        As such, a compromise of the private NSEC5 key does 
        not compromise the integrity of the zone. 
        An adversary that learns the private NSEC5 key can, however, perform 
        offline zone-enumeration attacks.  For this reason, the private NSEC5 key 
        need only be as secure as the DNSSEC records whose privacy (against zone 
        enumeration) is being protected by NSEC5. 
        A formal cryptographic proof 
        of this property is in  <xref target="nsec5" /> and <xref target="nsec5ecc" />.
        </t>

        <t>To preserve this property of NSEC5, the private NSEC5 key
        MUST be different from the private zone-signing keys or
        key-signing keys for the zone.
        </t>
        </section>

        <section title="Key Length Considerations" anchor="keylen">
        <t>
        The NSEC5 key must be long enough to withstand attacks
        for as long as the privacy of the zone contents is important. Even if the NSEC5 key
        is rolled frequently, its length cannot be too short, because zone privacy
        may be important for a period of time longer than the lifetime of the key.
        For example, an attacker might collect the entire chain of NSEC5 RR for the
        zone over one short period, and then, later (even after the NSEC5 key expires)
        perform an offline dictionary attack that  attempt to "reverse" the NSEC5
        hash values present in the NSEC5 RRs.
        This is in contrast to zone-signing and key-signing keys used in DNSSEC; these
        keys, which ensure the authenticity and integrity of the zone contents,
        need to remain secure only during their lifetime.
        </t>
        </section>

        <section title="NSEC5 Hash Collisions" anchor="hashcol">
        <t>
        If the NSEC5 hash of a QNAME collides with the NSEC5 hash of the 
	owner name of an NSEC5 RR, it will be impossible to prove the 
	non-existence of the colliding QNAME. However, the NSEC5 VRFs 
	ensure that obtaining such a collision is as difficult as obtaining 
	a collision in the SHA-256 hash function (requiring approximately 
	2^128 effort). Note that DNSSEC already relies on the assumption 
	that a cryptographic hash function is collision-resistant, since 
	these hash functions are used for generating and validating signatures 
	and DS RRs. See also the discussion on key lengths in 
	<xref target="nsec5" />.
        </t>
        </section>


    </section>

    <section title="IANA Considerations" anchor="iana_considerations">

        <t>
            This document updates the IANA registry "Domain Name System (DNS)
            Parameters" in subregistry "Resource Record (RR) TYPEs", by
            defining the following new RR types:
        </t>

        <t>
            <list>
                <t>NSEC5KEY   value TBD.</t>
                <t>NSEC5      value TBD.</t>
                <t>NSEC5PROOF value TBD.</t>
            </list>
        </t>

        <t>
            This document creates a new IANA registry for NSEC5 algorithms.
            This registry is named "DNSSEC NSEC5 Algorithms". The initial
            content of the registry is:
        </t>

        <t>
            <list>
                <t>0     is Reserved.</t>
                <t>1     is EC-P256-SHA256.</t>
                <t>2     is EC-ED25519-SHA256.</t>
<!--            <t>X     is RSAFDH-SHA256-SHA256.</t> -->
                <t>3-255 is Available for assignment.</t>
            </list>
        </t>

        <t>
            This document updates the IANA registry "DNS Security Algorithm Numbers" by
            defining following aliases:
        </t>

        <t>
            <list>
<!--            <t>TBD is NSEC5-RSASHA256, alias for RSASHA256 (8).</t>  -->
<!--            <t>TBD is NSEC5-RSASHA512, alias for RSASHA512 (10).</t> -->
                <t>TBD is NSEC5-ECDSAP256SHA256 alias for ECDSAP256SHA256 (13).</t>
<!--            <t>TBD is NSEC5-ECDSAP384SHA384 alias for ECDSAP384SHA384 (14).</t -->
                <t>TBD is NSEC5-ED25519, alias for ED25519 (15).</t>
<!--            <t>TBD is NSEC5-ED448, alias for ED448 (16).</t> -->
            </list>
        </t>

    </section>

    <section title="Contributors">
        <t>
            This document would not be possible without help of
            Moni Naor (Weizmann Institute),
            Sachin Vasant (Cisco Systems),
            Leonid Reyzin (Boston University), and
            Asaf Ziv (Weizmann Institute)
            who contributed to the design of NSEC5. 
            Ondrej Sury (CZ.NIC Labs), and
            Duane Wessels (Verisign Labs)
            provided advice on the implementation of NSEC5, and assisted with
            evaluating its performance.
        </t>
    </section>

</middle>

<back>
    <!-- References Section -->

<!--
     Section 4.7f of [RFC2223bis] specifies the requirements for the
     references sections.  In particular, there MUST be separate lists of
     normative and informative references, each in a separate section.
     The style SHOULD follow that of recently published RFCs.

     In general, each normative reference SHOULD reference the most recent
     version of the specification in question.
-->

    <references title="Normative References">
        &rfc1034;
        &rfc1035;
        &rfc2119;
        &rfc2136;
        &rfc2181;
        &rfc2308;
        &rfc4033;
        &rfc4034;
        &rfc4035;
        &rfc4648;
        &rfc5114;
        &rfc5155;
        &rfc6234;
        &rfc6605;
        &rfc7748;
        &rfc8080;

        <reference anchor="FIPS-186-3">
            <front>
                <title>Digital Signature Standard (DSS)</title>
                <author><organization>National Institute for Standards and Technology</organization></author>
                <date year="2009" month="June" />
            </front>
            <seriesInfo name="FIPS" value="PUB 186-3" />
        </reference>

        <reference anchor="SECG1" target="http://www.secg.org/sec1-v2.pdf">
            <front>
                <title>SEC 1: Elliptic Curve Cryptography</title>
                <author><organization>Standards for Efficient Cryptography Group (SECG)</organization></author>
                <date year="2009" month="May" />
            </front>
            <seriesInfo name="Version" value="2.0" />
        </reference>

    </references>

    <references title="Informative References">

        <reference anchor="nsec5" target="https://eprint.iacr.org/2014/582.pdf">
            <front>
                <title>NSEC5: Provably Preventing DNSSEC Zone Enumeration</title>
                <author initials="S." surname="Goldberg"><organization /></author>
                <author initials="M." surname="Naor"><organization /></author>
                <author initials="D." surname="Papadopoulos"><organization /></author>
                <author initials="L." surname="Reyzin"><organization /></author>
                <author initials="S." surname="Vasant"><organization /></author>
                <author initials="A." surname="Ziv"><organization /></author>
                <date year="2014" month="July" />
            </front>
             <seriesInfo name="in" value="NDSS'15" />
        </reference>

        <reference anchor="nsec5ecc" target="https://eprint.iacr.org/2017/099.pdf">
            <front>
                <title>Can NSEC5 be Practical for DNSSEC Deployments?</title>
                <author initials="D." surname="Papadopoulos"><organization /></author>
                <author initials="D." surname="Wessels"><organization /></author>
                <author initials="S." surname="Huque"><organization /></author>
                <author initials="J." surname="Vcelak"><organization /></author>
                <author initials="M." surname="Naor"><organization /></author>
                <author initials="L." surname="Reyzin"><organization /></author>
                <author initials="S." surname="Goldberg"><organization /></author>
                <date year="2017" month="February" />
            </front>
            <seriesInfo name="in" value="ePrint Cryptology Archive 2017/099" />
        </reference>

        <reference anchor="nsec3gpu">
            <front>
                <title>GPU-Based NSEC3 Hash Breaking</title>
                <author initials="M." surname="Wander"><organization /></author>
                <author initials="L." surname="Schwittmann"><organization /></author>
                <author initials="C." surname="Boelmann"><organization /></author>
                <author initials="T." surname="Weis"><organization /></author>
                <date year="2014" />
            </front>
            <seriesInfo name="in" value="IEEE Symp. Network Computing and Applications (NCA)" />
        </reference>

        <reference anchor="nsec3walker" target="http://dnscurve.org/nsec3walker.html">
            <front>
                <title>Nsec3 walker</title>
                <author initials="D. J." surname="Bernstein"><organization /></author>
                <date year="2011" />
            </front>
        </reference>


        <reference anchor="nmap-nsec-enum" target="https://nmap.org/nsedoc/scripts/dns-nsec-enum.html">
            <front>
                <title>nmap: dns-nsec-enum</title>
                <author initials="J. R." surname="Bond"><organization /></author>
                <date year="2011" />
            </front>
        </reference>

        <reference anchor="nmap-nsec3-enum" target="https://nmap.org/nsedoc/scripts/dns-nsec3-enum.html">
            <front>
                <title>nmap: dns-nsec3-enum</title>
                <author initials="A." surname="Nikolic"><organization /></author>
                <author initials="J. R." surname="Bond"><organization /></author>
                <date year="2011" />
            </front>
        </reference>

        
        <reference anchor="nsec3map" target="https://github.com/anonion0/nsec3map.">
            <front>
                <title>nsec3map with John the Ripper plugin</title>
                <author initials="" surname="anonion0"><organization /></author>
                <date year="2015" />
            </front>
        </reference>


        
        <reference anchor="ldns-walk" target="http://git.nlnetlabs.nl/ldns/tree/examples/ldns-walk.c">
            <front>
                <title>ldns</title>
                <author initials="" surname="NLNetLabs"><organization /></author>
                <date year="2015" />
            </front>
        </reference>
        
        <reference anchor="MRV99">
            <front>
                <title>Verifiable Random Functions</title>
                <author initials="S." surname="Michali"><organization /></author>
                <author initials="M." surname="Rabin"><organization /></author>
                <author initials="S." surname="Vadhan"><organization /></author>
                <date year="1999" />
            </front>
            <seriesInfo name="in" value="FOCS" />
        </reference>

        &rfc6781;
        &rfc7129;
        &rfc7719;
        &I-D.gieben-nsec4;
        
    </references>

    <section title="Elliptic Curve VRF" anchor="ecvrf">
        <t>
            The Elliptic Curve Verifiable Random Function (EC-VRF) 
            operates in a cyclic group G of prime order with 
            generator g. 
            The cyclic group G MAY be over the NIST-P256 elliptic curve, with curve 
            parameters as specified in <xref target="FIPS-186-3"/> 
            (Section D.1.2.3) and <xref target="RFC5114"/> (Section 2.6). 
            The group G MAY alternatively be over the Ed25519 elliptic curve 
            with parameters defined in <xref target="RFC7748"/> (Section 4.1). 
            The security of this VRF follows from the decisional 
            Diffie-Hellman (DDH) assumption in the cyclic group G 
            in the random oracle model. Formal security proofs for this VRF 
            are in <xref target="nsec5ecc"/>. 
        </t>

        <t>
            Fixed options:
            <list>
                <t>G - elliptic curve (EC) group</t>
            </list>
        </t>

        <t>
            Used parameters:
            <list>
                <t>g^x - EC public key</t>
                <t>x - EC private key</t>
                <t>q - prime order of group G</t>
                <t>g - generator of group G</t>
            </list>
        </t>

        <t>
            Used primitives:
            <list>
                <t>"" - empty octet string</t>
                <t>|| - octet string concatenation</t>
                <t>p^k - EC point multiplication</t>
                <t>p1*p2 - EC point addition</t>
                <t>SHA256 - hash function SHA-256 as specified in <xref target="RFC6234" /></t>
                <t>ECP2OS - EC point to octet string conversion with point compression as specified in Section 2.3.3 of <xref target="SECG1" /></t>
                <t>OS2ECP - octet string to EC point conversion with point compression as specified in Section 2.3.4 of <xref target="SECG1" /></t>
            </list>
        </t>

        <section title="EC-VRF Auxiliary Functions">


        <section title="EC-VRF Hash To Curve">
            <t>
                ECVRF_hash_to_curve(m)
            </t>
            <t>
                Input:
                <list>
                    <t>m - value to be hashed, an octet string</t>
                </list>
            </t>
            <t>
                Output:
                <list>
                    <t>h - hashed value, EC point</t>
                </list>
            </t>
            <t>
                Steps:
                <list style="numbers">
                    <t>c = 0</t>
                    <t>C = I2OSP(c, 4)</t>
                    <t>xc = SHA256(m || C)</t>
                    <t>p = 0x02 || xc</t>
                    <t>If p is not a valid octet string representing encoded compressed point in G:
                        <list style="letters">
                            <t>c = c + 1</t>
                            <t>Go to step 2.</t>
                        </list>
                    </t>
                    <t>h = OS2ECP(p)</t>
                    <t>Output h</t>
                </list>
            </t>

        </section>



        <section title="EC-VRF Hash Points">
            <t>
                ECVRF_hash_points(p_1, p_2, ..., p_n)
            </t>
            <t>
                Input:
                <list>
                    <t>p_x - EC point in G</t>
                </list>
            </t>
            <t>
                Output:
                <list>
                    <t>h - hash value, integer between 0 and 2^128-1</t>
                </list>
            </t>
            <t>
                Steps:
                <list style="numbers">
                    <t>P = ""</t>
                    <t>for p in [p_1, p_2, ... p_n]:
                       <vspace/>P = P || ECP2OS(p)
                    </t>
                    <t>h' = SHA256(P)</t>
                    <t>h = OS2IP(first 16 octets of h')</t>
                    <t>Output h</t>
                </list>
            </t>
        </section>

   
        <section title="EC-VRF Decode Proof">
            <t>
                ECVRF_decode_proof(pi)
            </t>
            <t>
                Input:
                <list>
                    <t>pi - VRF proof, octet string (81 octets)</t>
                </list>
            </t>
            <t>
                Output:
                <list>
                    <t>gamma - EC point</t>
                    <t>c - integer between 0 and 2^128-1</t>
                    <t>s - integer between 0 and 2^256-1</t>
                </list>
            </t>
            <t>
                Steps:
                <list style="numbers">
                    <t>let gamma', c', s' be pi split after 33-rd and 49-th octet</t>
                    <t>gamma = OS2ECP(gamma')</t>
                    <t>c = OS2IP(c')</t>
                    <t>s = OS2IP(s')</t>
                    <t>Output gamma, c, and s</t>
                </list>
            </t>
        </section>

        </section><!-- Auxiliary Functions -->

        <section title="EC-VRF Proving">
            <t>
                ECVRF_PROVE(g^x, x, alpha)
            </t>

            <t>
                Input:
                <list>
                    <t>g^x - EC public key</t>
                    <t>x - EC private key</t>
                    <t>alpha - message to be signed, octet string</t>
                </list>
            </t>

            <t>
                Output:
                <list>
                    <t>pi - VRF proof, octet string (81 octets)</t>
                    <t>beta - VRF hash, octet string (32 octets)</t>
                </list>
            </t>

            <t>
                Steps:
                <list style="numbers">
                    <t>h = ECVRF_hash_to_curve(alpha)</t>
                    <t>gamma = h^x</t>
                    <t>choose a nonce k from [0, q-1]</t>
                    <t>c = ECVRF_hash_points(g, h, g^x, h^x, g^k, h^k)</t>
                    <t>s = k - c*q mod q</t>
                    <t>pi = ECP2OS(gamma) || I2OSP(c, 16) || I2OSP(s, 32)</t>
                    <t>beta = h2(gamma)</t>
                    <t>Output pi and beta</t>
                </list>
            </t>
        </section>

        <section title="EC-VRF Proof To Hash">
            <t>
                ECVRF_PROOF2HASH(gamma)
            </t>
            <t>
                Input:
                <list>
                    <t>gamma - VRF proof, EC point in G with coordinates (x, y)</t>
                </list>
            </t>
            <t>
                Output:
                <list>
                    <t>beta - VRF hash, octet string (32 octets)</t>
                </list>
            </t>
            <t>
                Steps:
                <list style="numbers">
                    <t>beta = I2OSP(x, 32)</t>
                    <t>Output beta</t>
                </list>
            </t>
            <t>
                Note: Because of the format of the compressed form of an elliptic curve, the hash can
                be retrieved from an encoded gamma simply by omitting the first octet of the gamma.
            </t>
        </section>


        <section title="EC-VRF Verifying">
            <t>
                ECVRF_VERIFY(g^x, pi, alpha)
            </t>

            <t>
                Input:
                <list>
                    <t>g^x - EC public key</t>
                    <t>pi - VRF proof, octet string</t>
                    <t>alpha - message to verify, octet string</t>
                </list>
            </t>

            <t>
                Output:
                <list>
                    <t>"valid signature" or "invalid signature"</t>
                    <t>beta - VRF hash, octet string (32 octets)</t>
                </list>
            </t>

            <t>
                Steps:
                <list style="numbers">
                    <t>gamma, c, s = ECVRF_decode_proof(pi)</t>
                    <t>u = (g^x)^c * g^s</t>
                    <t>h = ECVRF_hash_to_curve(alpha)</t>
                    <t>v = gamma^c * h^s</t>
                    <t>c' = ECVRF_hash_points(g, h, g^x, gamma, u, v)</t>
                    <t>beta = ECVRF_PROOF2HASH(gamma)</t>
                    <t>
                        If c and c' are the same, output "valid signature";
                        else output "invalid signature". Output beta.
                    </t>
                </list>
            </t>

            <t><cref source="Jan">TODO: check validity of gamma before hashing</cref></t>
        </section>

    </section>

    <section title="Change Log">
        <t>
            Note to RFC Editor: if this document does not obsolete an existing RFC,
            please remove this appendix before publication as an RFC.
        </t>

        <t>
            <list>
                <t>
                    pre 00 - initial version of the document submitted to mailing list only
                </t>
                <t>
                    00 - fix NSEC5KEY rollover mechanism, clarify NSEC5PROOF RDATA, clarify
                    inputs and outputs for NSEC5 proof and NSEC5 hash computation.
                </t>
                <t>
                    01 - Add Performance Considerations section.
                </t>
                <t>
                    02 - Add elliptic curve based VRF. Add measurement of 
                    response sizes based on empirical data.
                </t>
                <t>
                    03 - Mention precomputed NSEC5PROOF Values in 
                    Performance Considerations section.
                </t>
                <t>
                    04 - Edit Rationale, How NSEC5 Works, and Security Consideration
                    sections for clarity.
                    Edit Zone Signing section, adding precomputation of NSEC5PROOFs. 
                    Remove RSA-based NSEC5 specification. 
                    Rewrite Performance Considerations and Implementation
                    Status sections.
                </t>
            </list>
        </t>
    </section>

<!--
    <section title="Open Issues">
        <t>
            Note to RFC Editor: please remove this appendix before publication as an RFC.
        </t>

        <t>
            <list style="numbers">
                <t>
                    Consider alternative way to signalize NSEC5 support. The NSEC5 could use
                    only one DNSSEC algorithm identifier, and the actual algorithm to be used
                    for signing can be the first octet in DNSKEY public key field and RRSIG
                    signature field. Similar approach is used by PRIVATEDNS and PRIVATEOID
                    defined in <xref target="RFC4034" />.
                </t>
                <t>
                    How to add new NSEC5 hashing algorithm. We will need to add new DNSSEC
                    algorithm identifiers again.
                </t>
            </list>
        </t>
    </section>
-->    

  </back>
</rfc>
<!-- vim: et ts=4 sts=4 sw=4 colorcolumn=100 spell :
-->
